*-----------------------------------------------------------
* Title      : CONVERT_HTA
* Written by : MICHAEL RITCHIE
* Date       : 6/2/2016
* Description: CONVERTS A HEX NUMBER TO ASCII AND LOADS IT TO A1, ALSO INCLUDE SUBROUTINE FOR PRINTING ADRESS AT (A4)
*-----------------------------------------------------------


    ORG    CONVERT_HTA
    
*-----------------------------------------------------------
*INSTRUCTIONS FOR CONVERT_HTA:

*SET THE VARIABLE HTA_CONVERT TO THE NUMBER YOU WANT TO CONVERT

*SET HTA_SIZE TO 1 FOR BYTE, 2 FOR WORD, OR 4 FOR LONG WORD 
*(YOU WILL HAVE TO DO THIS EVERY TIME YOU CALL THE SUBROUTINE)*

*IF DESIRED, SET HTA_LEADING_ZEROS TO 1 TO ELIMINATE LEADING ZEROS 
*(YOU WILL HAVE TO DO THIS EVERY TIME YOU CALL THE SUBROUTINE)*

*THIS SUBROUTINE WILL INCREMENT D1 AND PUSH DATA ONTO (A1) FOR PRINTING. ALL OTHER DATA REGISTERS USED
*ARE SAVED ONTO THE STACK AND RETORED BEFORE RETURNING
*-----------------------------------------------------------
CONVERT_HTA:

    *SAVE DATA REGISTERS D2,D3,D4 ONTO STACK
    MOVEM.L D2/D4,-(A7)
    
    CMP.B   #1,HTA_SIZE         *COMPARE HTA_SIZE TO 1
    BEQ READY_BYTE
    
    CMP.B   #2,HTA_SIZE         *COMPARE HTA_SIZE TO 2
    BEQ READY_WORD
    
    CMP.B   #4,HTA_SIZE         *COMPARE HTA_SIZE TO 4
    BEQ READY_LONG
    
    BRA RETURN_CONVERT_HTA      *IMPROPER SIZE SO RETURN
    
READY_BYTE
    MOVE.B  HTA_CONVERT,D4
    BRA PRINT_BYTE              *IF EQUAL BRANCH TO PRINT WORD

READY_WORD
    MOVE.W  HTA_CONVERT,D4
    BRA PRINT_WORD              *IF EQUAL BRANCH TO PRINT WORD
    
READY_LONG
    MOVE.L  HTA_CONVERT,D4
    BRA PRINT_LONG              *IF EQUAL BRANCH TOO WORD
    
PRINT_LONG
    MOVE.B #00,D2               *SET D2 TO 0 FOR LOOPING
LONG_LOOP
    CMP.B   #2,D2               *COMPARE D2 TO 2 TO END LOOP
    BEQ RETURN_CONVERT_HTA      *ALL DONE, RETURN
    ADD.B   #1,D2               *INCREMENT
    SWAP    D4                  *SWAP DATA AT D4 SO THAT THE LEFT HAND SIDE CAN BE PRINTED FIRST
    JSR PRINT_WORD              *PRINT THE LOWER WORD
    BRA LONG_LOOP               *LOOP BACK
PRINT_WORD

    ROR.W   #8,D4               *ROTATE THE WORD 8 BITS TO GET THE LEFT HAND BYTE FIRST
    JSR PRINT_BYTE              *PRINT THE LEFT HAND BYTE (NOW LOWER BYTE)
    ROR.W   #8,D4               *ROTATE THE WORD AGAIN TO GET THE RIGHT HAND BYTE
    JSR PRINT_BYTE              *PRINT THE RIGHT HAND BYTE (NOW LOWER BYTE)
    
    CMP.B #2,HTA_SIZE              *CHECK THE SIZE, IF THE SIZE IS 2 WE ARE DONE, SO RETURN
    BEQ RETURN_CONVERT_HTA
    RTS                         *THE SIZE DOES NOT MATCH, SO THIS WAS USED AS A SUBROUTINE, SO RETURN
PRINT_BYTE
    MOVE.B  D4,D3               *MOVE THE BYTE OF DATA AT D4 TO D3
    LSR.B   #4,D3               *GET THE FIRST BYTE FROM D3 FOR PRINTING
    
    JSR PRINT_DIGIT             *CONVERT THE DIGIT AT D3 TO ASCCI
    
    MOVE.B  D4,D3               *MOVE THE BYTE OF DATA AT D5 TO D3
    LSL.B   #4,D3               *SHIFT THE SENCOND BYTE AT D3 LEFT
    LSR.B   #4,D3               *SHIFT 2ND BYTE BACK RIGHT
    
    JSR PRINT_DIGIT             *CONVERT THE DIGIT AT D3 TO ASCII
    
    CMP.B #1,HTA_SIZE             *CHECK THE SIZE, IF THE SIZE IS ONE THEN WE ARE DONE SO RETURN
    BEQ RETURN_CONVERT_HTA
    RTS                         *THE SIZE DOES NOT MATCH, SO THIS WAS USED AS A SUBROUTINE, SO RETURN
PRINT_DIGIT
    CMP.B       #10, D3         * IF VALUE OF HEX IS GREATER OR EQUAL TO 10(A)
    BGE PRINT_LETTER            * VALUE IS #10-15, CONVERT LETTER
    BRA PRINT_NUMBER            * VALUE IS #0-9, CONVERT NUMBER
PRINT_LETTER
    CLR.B   HTA_LEADING_ZEROS   *A NON-ZERO DIGIT HAD BEEN FOUND SO DISABLE HTA_LEADING_ZEROS
    
    ADD.W       #$37, D3        * ADD #$37 TO D3, TO GET ASCII-HEX LETTER VALUE
    MOVE.B      D3, (A1)+       * ADD ASCII-HEX CHAR(A-F) TO A1, INCREMENT A1
    ADD.W       #1, D1          * INC CHAR COUNT 
    RTS
PRINT_NUMBER
    CMP.B #1,HTA_LEADING_ZEROS
    BEQ LEADING_ZERO_SET        *HTA_LEADING_ZEROS WAS SET, SO BRANCH TO LEADING_ZERO BEFORE PRINTING
    
    ADD.W       #$30, D3        * ADD #$30 TO D3, TO GET ASCII-HEX NUMBER VALUE
    MOVE.B      D3, (A1)+       * ADD ASCII-HEX CHAR(0-9) TO A1, INCREMENT A1
    ADD.W       #1, D1          * INC CHAR COUNT 
    RTS                         * GO BACK TO ABS_LOOP
LEADING_ZERO_SET
    CMP.B       #0,D3           *CHECK IF D3 IS 0. IF, SO IT IS A LEADING ZERO SO DON'T PRINT IT 
    BEQ RETURN_LEADING_ZERO     *RETURN WITHOUT PRINTING
    CLR.B   HTA_LEADING_ZEROS   *A NON-ZERO DIGIT HAD BEEN FOUND SO DISABLE HTA_LEADING_ZEROS
    
    ADD.W       #$30, D3        * ADD #$30 TO D3, TO GET ASCII-HEX NUMBER VALUE
    MOVE.B      D3, (A1)+       * ADD ASCII-HEX CHAR(0-9) TO A1, INCREMENT A1
    ADD.W       #1, D1          * INC CHAR COUNT 
RETURN_LEADING_ZERO
    RTS
    
RETURN_CONVERT_HTA
    *POP DATA FROM STACK
    MOVEM.L (A7)+,D2/D4
    *RESET VARIABLES
    CLR.L   HTA_CONVERT
    CLR.B   HTA_SIZE
    CLR.B   HTA_LEADING_ZEROS
    *RETURN
    RTS
    
PRINT_MEMORY_ADDRESS
    
    MOVE.B      #$24,(A1)+       *LOAD '$' INTO A1[4]
    ADD.W       #1,D1           INC CHAR COUNT
    
    MOVE.L  A4,HTA_CONVERT
    MOVE.B  #4,HTA_SIZE
    JSR CONVERT_HTA
    
    MOVE.B      #$20, (A1)+     * LOAD ' ' INTO A1[3]
    ADD.W       #1, D1          * INC CHAR COUNT
    MOVE.B      #$20, (A1)+     * LOAD ' ' INTO A1[3]
    ADD.W       #1, D1          * INC CHAR COUNT
    MOVE.B      #$20, (A1)+     * LOAD ' ' INTO A1[3]
    ADD.W       #1, D1          * INC CHAR COUNT
    
    RTS
    







*~Font name~Courier New~
*~Font size~10~
*~Tab type~1~
*~Tab size~4~
